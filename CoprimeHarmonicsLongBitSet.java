import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Implementation of the sieve of coPrimes described by Juan Manuel Fernandez in the following publication:
 * https://mirror.xyz/0x62514E8C74B1B188dFCD76D2171c96EF1845Ba02/PhwGsMoDsGGfbagtxAhjM5OyvIPnFfF6dhBYb4QICfQ
 */
public class CoprimeHarmonicsLongBitSet {
    static final int LEVEL_DEBUG = 1;
    static final int LEVEL_INFO = 2;
    static final int LEVEL_ERROR = 3;
    static final int LEVEL_NONE = 4;
    static final int LOG_LEVEL = LEVEL_INFO;

    /**
     * Max set of Generator primes to initialize {@link #pattern}.
     * Input to {@link #discardNonPrimesInPatternPOfGenerators(int)} or {@link #computePatternPOfCoprimesOfGenerators(int)}
     * must be <= MAX_GENERATORS.length.
     * For memory limitations 29 is the greatest generator prime here, depending on your system, you might add more
     * primes.
     */
    static final int[] MAX_GENERATORS = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

    /**
     * Working [P] for this run.
     */
    static LongBitSet pattern;

    /**
     * [G] generators primes needed to create harmonic of co-primes [P].
     */
    static List<Integer> generators = new ArrayList();

    public static void main(String[] args) {

        List<Integer> incompletePatternGeneratorPrimes = discardNonPrimesInPatternPOfGenerators(6);
        long period = pattern.length();

        Timer.start("sieveOfEratosthenes");
        LongBitSet sieveOfEratosthenes = SieveOfEratosthenes.sieveOfEratosthenes(period);
        Timer.stopAndPrint("sieveOfEratosthenes");

        info("Primes in sieveOfEratosthenes:" + SieveOfEratosthenes.cardinality());

        // -1 due to P[1] = 1, 1 is not prime, but is part of every Co-primes harmonic.
        info("Primes in Harmonics Sieve:    " + (pattern.cardinality() + incompletePatternGeneratorPrimes.size() - 1));

        if (LOG_LEVEL == LEVEL_DEBUG && sieveOfEratosthenes.cardinality() < 500L) {
            debug(incompletePatternGeneratorPrimes.toString());
            debug(pattern.toString());
            debug(sieveOfEratosthenes.toString());
        }
    }

    /**
     * Finds all primes in Pattern [P] generated by generator [G].This invalidates [P]1 (first harmonic pf [P]) as a
     * Harmonic. Instead it makes {@link #pattern} a first chunk of a (huge) incomplete/imaginary i[P], thus eliminating
     * more generator primes from [P] which are added to the returned list. So joining returned list with resulting [P]
     * will yield all primes between 1 and T(P), while enabling i[P] as an incomplete bigger harmonic.
     *
     * @param maxGenerators How any generators |G| do we want to generate [P] for.
     * @return a List of primes removed from [P] when eliminating non-primes in a way that would create larger and
     * larger [P] harmonics, but without extending [P] of [G] for provided |G| (maxGenerators), as that imaginary (i[P])
     * would not fit in memory, but the resulting (incomplete i[P]) can be used to offset n * T(iP) for testing
     * primality of big integers around n * T(iP). within the intervals [(n * T(iP)) - T(P); (n * T(iP)) + T(P)]. This
     * means that to get all primes in [P] you need to join returned List (imaginary/incomplete pattern generators i[G])
     * with resulting i[P] ({@link #pattern}).
     */
    static private List<Integer> discardNonPrimesInPatternPOfGenerators(int maxGenerators) {
        computePatternPOfCoprimesOfGenerators(maxGenerators);

        Timer.start("Eliminating non-primes from [P] (except 1)");

        // TODO: check ceiling (1 + ...) and overflowing.
        // To guarantee all numbers in pattern are primes we need to add generators up to
        // the square root of the pattern size. Where co-primes of generators and primes
        // are the same set.
        long length = pattern.length();
        int maxNeededGenerators = 1 + (int) Math.sqrt(length);

        List<Integer> incompletePatternGeneratorPrimes = new ArrayList<>(generators);
        long generator = incompletePatternGeneratorPrimes.get(incompletePatternGeneratorPrimes.size() - 1);

        while (generator <= maxNeededGenerators) {
            generator = pattern.nextSetBit(generator);
            if (generator > maxNeededGenerators) {
                break;
            }
            incompletePatternGeneratorPrimes.add((int) generator);
            for (long target = length / generator; target > 1; target -= 2) {
                target = pattern.previousSetBit(target);
                pattern.clearThrowIfAlreadyClear(target * generator);

                // Used just for debug, should throw if attempting to clear a 0 bit.
                // pattern.clear(target * generator);
            }
        }
        Timer.stopAndPrint("Eliminating non-primes from [P] (except 1)",
                String.format("Incomplete Harmonic has \n  T(iP) = %s " +
                        "\n  Allows to evaluate primality of integers in intervals [ n × T(iP) ± %s ]" +
                        "\n  With Generator primes: %s",
                        bigProductory(incompletePatternGeneratorPrimes),
                        pattern.length(),
                        incompletePatternGeneratorPrimes));

        printMetrics(pattern.length());
        return incompletePatternGeneratorPrimes;
    }

    /**
     * Calculates [P] of [G] generator primes. I.e. the harmonic set of co-primes of primes in [G]
     *
     * @param maxGenerators How any generators |G| do we want to generate [P] for.
     */
    static private void computePatternPOfCoprimesOfGenerators(int maxGenerators) {
        Timer.start("Pattern Array init");
        // Fixed max possible size, maxGenerators can't > number of inputs (10)
        long bitSetSize = productory(maxGenerators, MAX_GENERATORS);
        pattern = new LongBitSet(bitSetSize);
        Timer.stopAndPrint("Pattern Array init.", bitSetSize);

        Timer.start("Computing Co-Primes");
        pattern.set(1L, true);
        long nextPatternSize = 1;
        int generator = 0;
        int generatorCount = 1;
        while (generatorCount++ <= maxGenerators) {
            generator = nextGenerator(pattern, nextPatternSize);
            generators.add(generator);
            pattern.repeat(1L, nextPatternSize, generator - 1);
            long patternSize = nextPatternSize;
            nextPatternSize *= generator;

            for (long eliminationTarget = patternSize; eliminationTarget > 0; eliminationTarget--) {
                eliminationTarget = pattern.previousSetBit(eliminationTarget);
                pattern.clearThrowIfAlreadyClear(eliminationTarget * generator);

                // For faster runs use this instead.
                // pattern.clear(eliminationTarget * generator);
            }
        }
        long cardinality = pattern.cardinality();
        if (LOG_LEVEL == LEVEL_DEBUG && cardinality < 500L) {
            debug(pattern.toString());
        }
        Timer.stopAndPrint("Computing Co-Primes",
                String.format("|P| = %s ; T(P) = %s ; [G] = %s", cardinality, pattern.length(), generators));
        printMetrics(nextPatternSize);
    }

    private static int nextGenerator(LongBitSet pattern, long nextPatternSize) {
        long nextGeneratorPrime = pattern.nextSetBit(2L);
        if (nextGeneratorPrime == -1) {
            // Only possible when pattern is one of: [1] and n=1 ; [1, #] and n=2
            nextGeneratorPrime = nextPatternSize == 1 ? 2 : 3;
        }
        return (int) nextGeneratorPrime;
    }

    private static void printMetrics(long patternSize) {
        if (LOG_LEVEL > LEVEL_DEBUG) {
            return;
        }
        long cardinality = pattern.cardinality();
        long bitSetSize = pattern.size();

        debug("Final Pattern size vs LongBitSet: " + patternSize / (double) bitSetSize);
        debug("Final co-primes vs π(x): " + cardinality / (patternSize/Math.log(patternSize)));
        debug("Final patternSize vs π(x): " + patternSize / (patternSize/Math.log(patternSize)));
        debug("Final co-primes vs patternSize: " + cardinality / (double) patternSize);
        if (cardinality < 500L) {
            debug(pattern.toString());
        }
    }

    public static class Timer {
        static Map<String, Long> timersStartTime =  new HashMap<>();
        static void start(String timerName) {
            timersStartTime.put(timerName, System.nanoTime());
        }

        static double stop(String timerName) {
            Long removedStartTime = timersStartTime.remove(timerName);
            if (removedStartTime == null) {
                return -1;
            }
            long endTime = System.nanoTime();
            //divide by 1000000 to get milliseconds.
            return (endTime - removedStartTime) / 1000000D;
        }

        private static double stopAndPrint(String timerName, Object resultValue) {
            double stop = stop(timerName);
            info("\n * " + timerName + " Finished in " + stop + " ms. \n   With Value: \n    => " + resultValue);
            return stop;
        }

        private static double stopAndPrint(String timerName) {
            double stop = stop(timerName);
            info("\n * " + timerName + " Finished in " + stop + " ms.");
            return stop;
        }

        static double timeFn(Runnable r) {
            long startTime = System.nanoTime();
            r.run();
            long endTime = System.nanoTime();
            //divide by 1000000 to get milliseconds.
            return (endTime - startTime) / 1000000D;
        }
    }

    static long productory(int... inputs) {
        return productory(false, inputs);
    }

    private static long productory(int maxGenerators, int[] generatorsArray) {
        return productory(false, Arrays.copyOf(generatorsArray, maxGenerators));
    }

    static BigInteger bigProductory(List<Integer> inputs) {
        BigInteger result = BigInteger.valueOf(1L);
        for (int i : inputs) {
            result = result.multiply(BigInteger.valueOf(i));
        }
        return result;
    }

    static long productory(boolean ignoreMax, int... inputs) {

        long max = LongBitSet.MAX_POSSIBLE_SIZE;
        long result = 1L;
        for (int i : inputs) {
            debug("Productory Partial Rersult: " + result);
            result *= i;
        }
        if (! ignoreMax && max < result) {
            throw new IllegalArgumentException("Productory too large: " + result + "\n max is: " + max);
        } else {
            debug("Result: " + result + "\n could fit: " + ((double) max / (double) result - 1) + " times more");
            debug("Result: " + result + "\n is: " + (result / (double)Integer.MAX_VALUE) + " times int max vallue");
        }
        return result;
    }

    static void debug(final String message) {
        if (LOG_LEVEL > LEVEL_DEBUG) {
            return;
        }
        System.out.println(message);
    }

    static void info(final String message) {
        if (LOG_LEVEL > LEVEL_INFO) {
            return;
        }
        System.out.println(message);
    }

    static void error(final String message) {
        if (LOG_LEVEL > LEVEL_ERROR) {
            return;
        }
        System.out.println(message);
    }
}
